I"Í<p>Como vamos a trabajar en un cluster, necesitaremos un cluster de servidores, para eso podemos usar cualquiera de los que hay en el mercado por ejemplo AWS, Digital Ocean, Hetzner, etc. Claro que para pruebas podemos usar nuestro pc local.</p>

<p>Existen tambien diferentes clientes para usar Kubernetes por ejemplo k3s, k0s, kubectl.</p>

<h1 id="usando-el-cliente-kubectl">Usando el cliente Kubectl</h1>
<p>descargamos e instalamos kubectl</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl -LO "https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl"
</code></pre></div></div>

<p>Para instalarlo agregamos el kubectl al path
Habilita los permisos de ejecuciÃ³n del binario kubectl.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>chmod +x ./kubectl
</code></pre></div></div>
<p>Mueve el binario dentro de tu PATH.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo mv ./kubectl /usr/local/bin/kubectl
</code></pre></div></div>

<p>Para practicar los principios que debemos dominar en kibernetes vamos a usar Minikube
minikube is local Kubernetes, focusing on making it easy to learn and develop for Kubernetes.</p>

<p>All you need is Docker (or similarly compatible) container or a Virtual Machine environment, and Kubernetes is a single command away: <code class="language-plaintext highlighter-rouge">minikube start</code></p>

<p>requisitos:<br />
2 CPUs or more<br />
2GB of free memory<br />
20GB of free disk space<br />
Internet connection<br />
Container or virtual machine manager, such as: Docker</p>

<p>1 Installation de minikube</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
sudo install minikube-linux-amd64 /usr/local/bin/minikube
</code></pre></div></div>

<p>2 Start your cluster</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>minikube start
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> minikube v1.24.0 on Ubuntu 18.04
 Automatically selected the docker driver
 Starting control plane node minikube in cluster minikube
 Pulling base image ...
 Downloading Kubernetes v1.22.3 preload ...
 &gt; preloaded-images-k8s-v13-v1...: 501.73 MiB / 501.73 MiB  100.00% 154.79 K
 &gt; gcr.io/k8s-minikube/kicbase: 0 B [______________________] ?% ? p/s 57m55s
 Creating docker container (CPUs=2, Memory=2200MB) ...
 Preparing Kubernetes v1.22.3 on Docker 20.10.8 ...
 â–ª Generating certificates and keys ...
 â–ª Booting up control plane ...
 â–ª Configuring RBAC rules ...
 Verifying Kubernetes components...
 â–ª Using image gcr.io/k8s-minikube/storage-provisioner:v5
 Enabled addons: default-storageclass, storage-provisioner
 Done! kubectl is now configured to use "minikube" cluster and "default" name
ce by default
</code></pre></div></div>

<p>3 Interact with your cluster
If you already have kubectl installed, you can now use it to access your shiny new cluster:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get po -A
</code></pre></div></div>

<p>Alternatively, minikube can download the appropriate version of kubectl and you should be able to use it like this:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>minikube kubectl -- get po -A
</code></pre></div></div>

<p>You can also make your life easier by adding the following to your shell config:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>alias kubectl="minikube kubectl --"
</code></pre></div></div>
<p>Initially, some services such as the storage-provisioner, may not yet be in a Running state. This is a normal condition during cluster bring-up, and will resolve itself momentarily. For additional insight into your cluster state, minikube bundles the Kubernetes Dashboard, allowing you to get easily acclimated to your new environment:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>minikube dashboard
</code></pre></div></div>

<h2 id="deploy-applications">Deploy applications</h2>
<p>Create a sample deployment and expose it on port 8080:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl create deployment hello-minikube --image=k8s.gcr.io/echoserver:1.4
kubectl expose deployment hello-minikube --type=NodePort --port=8080
</code></pre></div></div>
<p>It may take a moment, but your deployment will soon show up when you run:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get services hello-minikube
</code></pre></div></div>
<p>The easiest way to access this service is to let minikube launch a web browser for you:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>minikube service hello-minikube
</code></pre></div></div>
<p>Alternatively, use kubectl to forward the port:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl port-forward service/hello-minikube 7080:8080
</code></pre></div></div>
<p>Tada! Your application is now available at http://localhost:7080/.</p>

<p>You should be able to see the request metadata from nginx such as the CLIENT VALUES, SERVER VALUES, HEADERS RECEIVED and the BODY in the application output. Try changing the path of the request and observe the changes in the CLIENT VALUES. Similarly, you can do a POST request to the same and observe the body show up in BODY section of the output.</p>

:ET
---
layout: post
title: "Laravel 8"
date: 2021-05-15 12:23:10 -0400
relatives: laravel8
categories: [programming,php]
---

## Laraval:

## Convenciones de nombrado
Laravel como otros frameworks usa convención sobre configuración, en varios casos laravel se vale de estas convenciones para simplificar tareas ya que asume y hasta cierto punto impone su uso, conocer estas convenciones permite ahorrar mucho tiempo a la hora de programar.

### Controladores
Por **convención** los controladores deben estar en **singular**, sin espacios entre palabras, y la primer letra de cada palabra debe ser mayuscula **(PascalCase)** y deben terminar con la palabra Controller.
* UserController
* OrderDetailController

### Funciones
Las funciones deben ser nombradas aplicando camelCase.
* getUser()
* setIsAdminAttribute()
* orderDetails()

### Modelos
Para nombrar a los modelos tomamos el nombre de la entidad en singular y siempre aplicando PascalCase. Veamos algunos ejemplos:
* User
* OrderDetail

Los metodos dentro de los modelos se nombran en minuscula y en plural o singular dependiendo de si la relaciones de muchos o uno. nombrando las relaciones a muchos en plural y las relacions a uno en singular

Las relaciones muchos a muchos se nombran combinando los nombres de las tablas de la relacion en singular y en orden alfabetico, por ejemplo la relación entre Usuarios y Roles seria: role_user

### En la BD
* Es recomendable el uso de sustantivos en idioma inglés.
* Nombres de tablas: Usa sustantivos en *minúsculas* y en *plural*, y con snake_case. 
* Nombres de campos/columnas/atributos: Usa sustantivos en *minúsculas* y en *singular* y usando snake_case.

### Pruebas
Para nombras los métodos de prueba antepondremos test, el resto del nombre debe ser una descripción del tipo de prueba que se realice, siguiendo lo ya mencionado en la sección funciones. Para el estilo de nombrado se emplea camelCase. 
* testGetUserOrderHistory()
* testCreateAndAssignRolesToAUser()

### Rutas 
Los sustantivos en las rutas deben ser indicadas en plural, aplicando durante todo esto kebab-case
/customers/23
/orders

### Vistas
se usa la misma convención que para las rutas, mel sustantivo en minuscula y plural para crear el nombre del directorio que contiene las vistas. Cada uno de los archivos suelen llamarse como las funciones del controlador aunque no es necesario.




## Creación de un proyecto
Creación de proyecto con composer
```
composer create-project laravel/laravel LaravelDeComposer
```

Esto crea un proyecto laravel con los siguientes documentos.
<pre>
app        composer.json  database      public     routes      tests
artisan    composer.lock  package.json  README.md  server.php  vendor
bootstrap  config         phpunit.xml   resources  storage     webpack.mix.js
</pre>

Si queremos especifcar una versión de laravel:  
`composer create-project laravel/laravel LaravelLTS 5.1.x`

Si usamos la box Homestead de vagrant, configuramos el espacio de trabajo y directorios compartidos entre la maquina host y la maquina guest, algunos parametros del archivo Homestead.yaml coresponden al nombre del proyecto en el host y el sitio de donde se va a tomar ese proyecto en la maquina guest.
<pre>
sites:
	- map: homestead.test
	  to: /home/vagrant/code/blog/public
</pre>

## Route Files
El archivo routes/web.php contiene las instrucciones de como deben ser procesadas las urls

```php
use Illuminate\Support\Facades\Route;

Route::get('/greeting', function () {
    return 'Hello World';
});
```

esta url tambien puede tener parametros variables
```php
use Illuminate\Support\Facades\Route;

Route::get('/greeting/{name}', function ($name) {
    return $name;
});
```

Mas opciones [https://laravel.com/docs/8.x/routing](https://laravel.com/docs/8.x/routing)

El archivo web.php es mejor que procese las entradas pero que cada uno de las funciones se ejecuten en otro sitio, 
es decir en diferentes controladores

Laravel al igual que muchos otros frameworks usa el esquema MVC ( modelo-vista-controlador ) 

<p align="center">
<img src="{{site.baseurl}}/assets/img/posts/{{page.relatives}}/mvc_01.png?raw=true">
</p>

## Controladores
Lon controladores pueden crearse manualmente al crear un archivo php con su respectivo nombre dentro del directorio `/app/http/controller`
Tambien podemos hacerlo desde la terminal con el comando, por convención se coloca el nombre del controlador seguido de la palbra controller:	
`php artisan make:controller PageController` 

El archivo creado tiene algunas instrucciones, para hacer uso de ese controlador lo indicamos 
incluyendo `use App\Http\Controllers\PageController` en el archivo routes/web.php y llamando a la función con `PageController::Class`  asi:

```php
<?php

use Illuminate\Support\Facades\Route;
use App\Http\Controllers\PageController;


Route::get('/', PageController::Class);

```

y en la funcion que lo llama 
```php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class PageController extends Controller
{
    //
    public function __invoke(){
    	return "hello World";
    }
}

```

Si  vamos a crar varias funciones las llamamos con su nombre y no usamos la función \_\_invoke, esta funcion se usa cuando hay un unico metodo.

Lo siguiente muestra un controlador con varias funciones, como es creado en el archivo controlador y como se escribe la llamada desde routes/web.php, pasando un aray formado por e controlador y la función a la cual va a acceder


web.php
```php
<?php

use Illuminate\Support\Facades\Route;
use App\Http\Controllers\PageController;
use App\Http\Controllers\CursoController;


Route::get('/', PageController::Class);

Route::get('cursos', [CursoController::Class, 'index']);

Route::get('cursos/create', [CursoController::Class, 'create']);

Route::get('cursos/{curso}', [CursoController::Class, 'show']);

``` 

CursoController.php
```php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class CursoController extends Controller
{
    //
    public function index()
    {
    	return "cursos ";
    }

    public function create()
    {
    	return "curso creado con exito ";
    }

    public function show($curso)
    {
    	return "el curso es $curso ";
    }
}

```

El modo usado anteriormente para invocar un controlador seria
```
Route::get('/', 'PageController');

Route::get('cursos', 'CursoController@index');

Route::get('cursos/create', 'CursoController@create');
```

## Vistas

Las vistas se crean dentro del directoio resources/views/
si el controlador tiene una unica funcion podemos simplemente crear dentro de views un archivo .php si el controlador tiee varias funciones se crea un subdirectorio que tiene por nombre el sustantivo usado en la url siguiendo su misma convención, en minuscula y plural dentro se crear archivos .php cada uno correspondiente a las funciones definidas en el controlador respectivo

cada uno de estos archivos son vistas html con etiquetas php, estos archivos se llaman asi, para que el controlador pueda llamar a las vistas llamamos a la funcion view() a esta funcion le indicamos el nombre de la vista con el parametro, notese que cuando la funcion tiene parametro le indicamos como va a ser nombrada esa variable en la vista, la palabra 'curso' corresponde al nombre que va a tomar la variable $curso en la vista, podriamos haber asignado otro nombre
ejemplos
```php
return view('home');
return view('cursos.index');
return view('cursos.create');
return view('cursos.show', ['curso'=> $curso ]);

```
Otra forma de mandar variables en caso de que el nombre coincida con la variable que queremos usar en la vista es usando la funcion compact() asi:
```php

return view('cursos.show', compact('curso') );
```

## plantillas
Para reutilizar codigo html comun a varias paginas usamos plantillas que en realidad son un tipo de archivo .blade.php

dentro de la carpeta view creamos una carpeta llamada layouts, dentro de esta carpeta creamos las plantillas, por ejemplo plantilla.blade.php, este archivo tiene una estructura propria
en esta plantilla copiamos nuestro codigo html, en las partes que queremos que sean variables usamos una etiqueta **@yield**
por ejemplo el archivo plantilla.blade.php quedaria
```php
<!DOCTYPE html>
<html>
<head>
    <title>@yield('title')</title>
</head>
<body>

    @yield('content')

</body>
</html>
```

Luego a las vistas que quiero que hereden de esta plantilla se lo indicamos usando la etiqueta **@extends('layouts/plantilla')**, y el respectivo contenido lo indicamos con **@section('nombre','contenido')** o si el contenido es mas extenso con **@section('nombre')** ... **@endsection**.

archivo plantilla.blade.php
```php
<!DOCTYPE html>
<html>
<head>
    <title>@yield('title')</title>
</head>
<body>

    @yield('content')

</body>
</html>
```

archivo page.blade.php, **Notese que el archivo page.php cambia a page.blade.php**

```
@extends('layouts.plantilla')

@section('title','Home')

@section('content')
<?php echo "<h1>hello World</h1>"; ?>
@endsection
```

si parte de la vista debe imprimir algo como <?php echo $variable; ?> blade provee un atajo para esto usando las etiquetas **\{\{$variable \}\}**
```php
 { {$curso} }
```

## Modelos

Creamos una base de datos, nos dirigimos al archivo config/databases para definir que tipo de base de datos vamos a usar asignando los valores manualmente o usando el archivo env, lo recomendable es usar el archivo env ya que de esta forma nos aseguramos que no estaremos subiendo credenciales a nuestros repositorios.

A la hora de crear tablas podemos hacerlo de varias formas, una forma algo rudimentaria es crear las instrucciones sql manualmente e insertarlas en la base de datos, luego de esto hacemos las consultas usando ORM u algun otro metodo. Esta no es la mejor alternativa, lo mejor sería crear las instrucciones en el archivo database/migrations, este archivo define una estructura para crear las tablas desde laravel, y en caso de que queramos revertir un cambio tambien define mecanismos para hacerlo. el directorio database/migrations tiene archivos que corresponden a cada tabla, por ejemplo uno de estos archivos contiene
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

class CreateUsersTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('users', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->string('email')->unique();
            $table->timestamp('email_verified_at')->nullable();
            $table->string('password');
            $table->rememberToken();
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('users');
    }
}


```

Para conectarse a un modelo diferente a lo esperado por Laravel, definimos en el archivo Model\Name
```php
class TableA extends Model
{
    protected $table = 'database1.usuario';
    protected $primaryKey = "Id";

   public function info() {
    ...
```

De aqui nos interesan las funciones Up y Down.
La función Up usa el metodo Blueprint que es el que indica que se va a crear una tabla en este caso llamada `users`y dispone de funciones que hacen referencia a los campos de una inserción en base de datos, por ejemplo **$table->id()** va a crear un identificador asociado a un primary key, la funcion string define un string de maximo 255 caracteres, timestamp hace referencia a fechas que en este caso son usadas para la verificación de correos, rememberToken es usado para recordar el acceso o las sesiones cada vez que un usuario inicia sesion. mas detalles de estos metodos pueden consutlarse en la sección migrations del sitio oficial de laravel.

Para ejecutar una migración ejecutamos el comando, el cual crea las tablas en la base de datos
```
php artisan migrate
``` 

Para crear nuestras proprias migraciones, nuevamente podemos ejecutar un comando que simplifica la tarea de crear el archivo por nosotros. eso crea un archivo ya con los metodos para uqe nosotros completemos.
```
php artisan make:migration cursos
```

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

class Cursos extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        //
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        //
    }
}
```

PAra revertir los cambios realizados sobre lotes hacemos 
```
php artisan migrate:rollback
```

Otra forma de crear archivos de migraciones mas acorde a convenciones es usando el comando:
`php artisan make:migration create_cursos_table` esto crea el archivo pero ademas completa ciertos campos  completa ciertos campos 

```
php artisan make:migration create_cursos_table
```

quedando asi:
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

class CreateCursosTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('cursos', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->text('descripcion');
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('cursos');
    }
}

```

Si realizo alguna modificación en los campos y quiero actualizar podría hacer rollback para luego volver a migrar, pero tambien puedo ejecutar el comando fresh que recorre una a una las migraciónes borrandolas y volviendolas a subir
```
php artisan migrate:fresh
```

Si queremos agregar un campo a una tabla sin borrar los datos lo indicamos con el comando make:migration pero debemos seguir una convención de nombrado, add_nombrecampo_to_enlatabla_table, el siguiente comando crea  un archivo que tiene una estructura diferente al create, que tiene el proposito de crear un campo avatar a la tabla users
```
php artisan make:migration add_avatar_to_users_table 
```

El archivo creado contiene
```php
    public function up()
    {
        Schema::table('users', function (Blueprint $table) {
            //
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::table('users', function (Blueprint $table) {
            //
        });
    }
```

dentro de la función up, podemos agregar el o los campos a modificar, debemos tener en cuenta tambien el proceso inverso quedando el archivo asi:
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

class AddAvatarToUsersTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::table('users', function (Blueprint $table) {
            //
            $table->string('avatar')->nullable();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::table('users', function (Blueprint $table) {
            //
            $table->dropColumn('avatar');
        });
    }
}
```

Si quiero agregar el nuevo campo en un orden especifico, por ejemplo despues del campo email, en la función up la defino asi
```
...
$table->string('avatar')->nullable()->after('email');
...
``` 

Si lo que quiero es modificar un campo que ya existe, usando la convención ejecutaria el comando `php artisan make:migration cambiar_propiedades_to_users_table` y en la función up
usaria la propiedad change, por ejemplo para cambiar la longitud del campo name
```
$table->string('name',150)->change();
```


## Eloquent ORM:

Los Modelos tienen siguiendo la convención que llamarse con mayuscula en singular
para crear un modelo hacemos

```php
php artisan make:model Curso
```

Ahora si queremos intearactuar con este objeto
podemos usar el comando 
```
php artisan tinker
```
Eso abre una consola donde podemos manualmente probar consultas desde el objeto por ejemplo
```
>>> use App\Models\Curso;
>>> $curso = new Curso;
=> App\Models\Curso {#3341}
>>> $curso->name = 'Laravel';
=> "Laravel"
>>> $curso->descripcion = 'el mejor framework de php';
=> "el mejor framework de php"
>>> $curso->save();
=> true
```

Si volvemos a mostrar $curso; podemos ver que ya tiene asignado un id
```
=> App\Models\Curso {#3341
     name: "Laravel",
     descripcion: "el mejor framework de php",
     updated_at: "2021-04-22 18:42:20",
     created_at: "2021-04-22 18:42:20",
     id: 1,
   }
```

Si realizamos alguna modificación modifica la fecha de update


Al usar la convención no es necesario definir que se conecte a la tabla cursos por ejemplo
Laravel por la convención puede determinar que si te Refieres a Curso va a modificar la tabla cursos, que pasa si no queremos aplicar la convencion lo definimos en el modelo Curso
con la instruucción **protected $table = 'users'**

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Curso extends Model
{
    use HasFactory;
    protected $table = 'users';
}
```

## Seeders
Si quero poblar el contendo deuna tabla con texto de prueba, voy al directorio **databases** / **seeders** y abro el archivo **Databaseseeders**
y dentro de la función run vamos a agregar el contenido que habiamos agregado anteriormente en tinker
```php
<?php

namespace Database\Seeders;

use App\Models\Curso;
use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    /**
     * Seed the application's database.
     *
     * @return void
     */
    public function run()
    {
        $curso = new Curso;

        $curso->name = 'Laravel';
        $curso->descripcion = 'El mejor framework de php';
        $curso->categoria = "Desarrollo Web";

        $curso->save();
    }
}


``` 
Si queremos que se carguen estos cambios hacemos creando un curso hacemos

```
php artisan db:seed
```

Ahora si queremos separar el archivo seeder creamos un nuevo seeder 
``` 
php artisan make:seeder CursoSeeder
``` 

y luego agregar dentro de DatabaseSeeder.php en la funcion run 
```
$this->call(CursoSeeder::class   );
``` 

y luego hacemos 
``` 
php artisan migrate:fresh
php artisan db:seed
```

o simplemnte 
``` 
php artisan migrate:fresh --seed
```


## Factory
Nos permite llenar una base de datos con datos de prueba
```
php artisan make:factory CursoFactory
```
Esto crea dentro de la carpeta Database/Factory un nuevo documento llamado CursoFactory 
este documento 
```php
<?php

namespace Database\Factories;

use App\Models\Curso;
use Illuminate\Database\Eloquent\Factories\Factory;

class CursoFactory extends Factory
{
    /**
     * The name of the factory's corresponding model.
     *
     * @var string
     */
    protected $model = Curso::class;

    /**
     * Define the model's default state.
     *
     * @return array
     */
    public function definition()
    {
        return [
            //
        ];
    }
}
```

À este documento debemos llenar el array return los campos que tiene la tabla, 
```php
...
    public function definition()
    {
        return [
            'name' => $this-> faker->sentence(),
            'descripcion' => $this-> faker-> paragraph(),
            'categoria' => $this-> faker-> randomElement(['Desarrollo Web','Diseño Web'])
        ];
    }
...
```

Para llamarlo vamos a la Archivo CursoSeeder y desde ahi llamamos la clase Curso::factory(50)->create()
```php
<?php

namespace Database\Seeders;

use App\Models\Curso;
use Illuminate\Database\Seeder;

class CursoSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        //
        Curso::factory(50)->create();
    }
}

```


## Consultas desde Eloquent
Para recoger registros de una tabla debo indicar el modelo que se encarga de administrar una tabla
```
use App\Models\Curso
``` 

Para recuperar todos los campos
```
$cursos = Curso::all();
```

Si yo quisiera filtrar los registros a aquellos que coincidan con la categoria 'Diseño Web'
```php
$curso = Curso::where('categoria','Diseño Web')->get();
```
Para ordenar el resultado de forma descendente  
```php
$curso = Curso::where('categoria','Diseño Web')->orderBy('id',desc)->get();
```
ordena por nombre de forma ascendente  
```
$curso = Curso::where('categoria','Diseño Web')->**orderBy('name',asc)**->get();
```

Obtiene solo el primer resultado  
```
`$curso = Curso::where('categoria','Diseño Web')->orderBy('name',asc)->frist();`
```
Otras consultas
```
$curso = Curso::select('name','descripcion')->where('categoria','DiseñoWeb')->orderBy('name',asc)->get();
```

```
Curso::select('name as title','descripcion')->where('categoria','DiseñoWeb')->orderBy('name',asc)->get(); 
```

```
Curso::select('name as title','descripcion')->where('categoria','DiseñoWeb')->orderBy('name',asc)->take(5)->get(); 
```

```
$curso = Curso::select(name)->where('categoria','Diseño Web')->orderBy('name')->take(2)->get()
```

Esto es buscar por id =5
```
$curso = Curso::where('id',5)->first()
```
Lo mismo podemos hacerlo 
```
$curso = Curso::find(5)
```

### Consultas mas completas
Todos los valores con id mayor a 45
```php
Curso::where('id','>',45)->get(); 
```

```
Curso::where('name','like','%olup%')->get(); 
```

## Consultas desde el controlador

Incluimos el modelo a usar
`use App\Models\Curso`

y hacemso la consulta que vayamos a hacer
retornandola o pasandola a una vista
por ejemplo:
```
$cursos = Curso::all();
return $cursos;
```

si queremos pasarlo a una vista
```php
$cursos = Curso::all();
return view('cursos.index', ['cursos' => $cursos ] );
```

luego desde la vista si es del formato blade.php recuperamos la variable con { { $cursos }}
```php
@extends('layouts.plantilla')

@section('title','Home')

@section('content')
<h1> Bienvenidos</h1>
<ul>

    @foreach( $cursos as $curso )
        <li>{ {$curso}}</li>
    @endforeach

</ul>
@endsection
```
podemos mostrar algunos campos en particular asi.
```php
...
 @foreach( $cursos as $curso )
        <li>{ {$curso->name}}</li>
    @endforeach

</ul>
...
```

Lo anterior traeria todos los cursos, algo ma correcto sería paginar el resultado, para conseguir esto desde el controlador hacemos
```php
    public function index()
    {
        $cursos = Curso::paginate();
        return view('cursos.index', ['cursos' => $cursos ] );
        //view('cursos.index');
    }

```
luego desde la url podemos ingresar a la ruta  **http://localhost:8000/cursos?page=2** para mostrar los siguientes resultados

Para agregar los botones de navegación entre paginas, en la vista agregamos 
` { { $cursos->links() }}`


Laravel recomienda el nombrado de las rutas internas de una aplicacion, en el archivo routes/web.php
teniamos las siguientes rutas, asi cada vez que colocamos un enlace lo acemos apuntando a ese nombre y no a la ruta como tal que podría cambiar.

```php
Route::get('/', PageController::Class);

Route::get('cursos', [CursoController::Class, 'index'])->name('cursos.index');

Route::get('cursos/create', [CursoController::Class, 'create'])->name('cursos.create');

Route::get('cursos/{curso}', [CursoController::Class, 'show'])->name('cursos.show');
```

Y luego cuando vayamos a hacer referencia a alguna de estas rutas lo hagamos asi:
``` 
< href="{ { route(cursos.create) }}">enlace</a>
``` 

Para enviar información desde formularios Laravel exige la activación de un toquen para evitar ataques de csrf, para incluir esta directiva agregamos al formulario o antes esta directiva
```
@csrf
```

Para recibir los datos del formulario en el controlador uso el recurso request de la siguiente forma
```php
public function store(Request $request)
    {
    return $request -> all();
    }
```

al hacer un envio podemos ver
```
_token  "ugJDdC6UxEQKHrasIhwkEP7mq7MX20ebNXFG9pdM"
name    "Javascript"
descripcion "cuso de progamacion del lado del cliente"
categoria   "Desarrollo Web"
```

Si yo recibo el parametro de un id que kluego quiero buscar en la base de datos por ejemplo en el modelo Curso asi 
<pre>
    public function edit($id)
    {
        $curso = Curso::find($id);
        return $curso;
    }
</pre>
Puedo en realidad pedir el $id e indicarle que se trata de tipo curso, laravel automaticamente hace la busqueda de el curso que tiene ese $id, el siguiente codigo daria el mismo resultado que lo anterior
```php
public function edit(Curso $id)
    {
        return $id;
    }

```

Para forzar la directiva del metodo put en actualizaciones de formulario indicamos a Laravel dentro del formulario `@method('put')` tal que asi:
```php


<form action="{ {route('cursos.update', $curso)}}" method="post">
    @csrf
    @method('put')
    <label>
        Nombre:<br>
        <input type="text" name="name" value="{ { $curso->name }}"><br>
    </label>
    <label>
    ...
```

## Validar valores
Antes de enviar valores a una base de datos es necesario validarlos, para esto Laravel provee la funcion validate que funciona asi
```  
$request -> validate()
```  
a esta función se le pasa un array que contiene todas las reglas de validacion que queremos
```php
$request -> validate([
 'name' => 'required',
 'descripcion' => 'required',
 'categoria' => 'required',
    ]);
```  
Esto por si solo captura el error y detiene el flujo de ejecución retornando al formulario pero no da indicios al usuario que que ha pasado. es importante que en la vista se muestre el error al usuario esto se consigue con la directiva error que se incluye en la vista, es decir en el formulario

```php 
@error('name')
{ {$message}}
@enderror
```

Estos mensajes en ingles pueden ser modificados y cambiado el idioma 
resources/lang/en hay 4 archivos que contienen los mensajes mostrados por laravel segun la tarea, pro ejemplo mensajes de authenticacion, de paginación, de passwords y de validación. Podemos copiar esa carpea y traducir los mensajes para tener nuestra versión en español o descargamos 
[https://github.com/Laraveles/spanish/tree/master/resources/lang](https://github.com/Laraveles/spanish/tree/master/resources/lang) este contendio lo pegamos dentro del directorio lang, ademas tammbien se puede personalizar

Para indicarle a Laravel que utilice los mensajes en epañol modificamos el archivo **config/app.php**
y modificamos donde dice `locale = en` el valor en en toma los datos de la carpeta `en` de ingles lo modificamos por `locale = es` 
 
 Ademas el archivo validation.php contiene un array atributes, que permite que nosotros modifiquemos el nombre de los atributos asi al indicar mensajes como, el campo name es necesario, podemos mapear name por Nombre, ya que toma el atributo del campo name de los formularios. y resulta conveniente definirlos en ingles.

```
    | of "email". This simply helps us make messages a little cleaner.
    |
    */

    'attributes' => [],

];
```

```
    | of "email". This simply helps us make messages a little cleaner.
    |
    */

    'attributes' => [
      'name' => 'Nombre'
    ],

];
```

Por defecto cada vez que se envia el formulario cuando falta algun campo todo el formulario se vacia, aun cuando se captuaran los errores, lo correcto seria conservar los campos que hayan sido lleados, esto se consigue con la propiedad **old** en el formulario. por ejemplo para create.
los campos quedarian  quedarian de la siguiente forma

 ```
 <form action="{ {route('cursos.store')} }" method="post">
    @csrf
    <label>
        Nombre:<br>
        <input type="text" name="name" value="{ { old('name') } }"><br>
    </label>
    <br>
    @error('name')
    * { {$message} }
    @enderror
    <br>
    <button type="submit">Enviar formulario</button>
</form>
 ```

Usar el metodo old con formularios de **actualización**, el tipo de problema que puede presentarse cuando hay un valor preexistente y se usa old  es que no aparece el valor de base de datos
para eso usamos un segundo parametro
```
<input type="text" name="name" value="{ { old('name', $curso->name) } }"><br>
```

La opcion validate admite mas reglas de validacion, por ejemplo que tenga una cierta cantidad de caracteres
```php
        $request -> validate([
        'name' => 'required|max:10',
        'descripcion' => 'required|min:10',
        'categoria' => 'required',
        ]);

``` 


## Form Request

En este caso se quiere crear un formulario de validación para el metodo store
```
php artisan make:request StoreCurso
```
Esto crea un archivo App/Http/Request/StoreCurso.php que luce asi:
```php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class StoreCurso extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        return false;
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            //
        ];
    }
}
``` 

Este archivo se separa en 2 partes una para las reglas de atenticacion que se deben cumplir, le indicamos en la funcion authorize que retorne true, ya que no vamos a usar esas reglas.

en la funcion rules definimos las relgas que habriamos definido en un validate. y luego le pasamos el Request al Controlador para que pueda usar estas reglas. luego terminamos incluyendolo en el tipo de dato del request
asi:

Archivo storeCurso.php
```php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class StoreCurso extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        return true;
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            'name' => 'required',
            'descripcion' => 'required',
            'categoria' => 'required'
        ];
    }
}
```

en el controlador usamos este archivo
```php
<?php

namespace App\Http\Controllers;

use App\Models\Curso;
use Illuminate\Http\Request;
use App\Http\Requests\StoreCurso           <===== HERE

class CursoController extends Controller
{
```

y luego eliminamos las reglas validate y cambiamos el parametro en la funcion store
asi:
```php 
use App\Http\Requests\StoreCurso

...

    public function store(StoreCurso $request)
    {

        $curso = new Curso();
        $curso->name = $request->name;
        $curso->descripcion = $request->descripcion;
        $curso->categoria = $request->categoria;
        $curso->save();
        return redirect()->route('cursos.show',$curso->id);
    }
``` 

Si dentro del archivo StoreCurso.php creo una función atributos estaria reemplazando el uso del campo atributos en el archivo lang/es/validation.php
```php
    public function attributes(){
        return [
            'name' => 'nombre del curso',
        ];
    }
```

Igualment epodriamos personalizar los mensajes creando un metodo messages
```php
    public function messages(){
        return [
            'descripcion.required' => 'Debe ingresar una descripción del curso',
        ];
    }
```


## Asignacion masiva:

Para insertar un objeto en nuestro modelo habiamos creado la instancia de curso asi
```php
    $curso = new Curso();
    $curso->name = $request->name;
    $curso->descripcion = $request->descripcion;
    $curso->categoria = $request->categoria;
    $curso->save();
```

Laavel nos permite usar la función create que recibe un array asi:
```php
    $cuso = Curso::create([
    'name' => $request->name,
    'descripcion' => $request->descripcion,
    'categoria' => $request->categoria
    ]);
```

Como esta función recibe un array podemos pasarle **$request->all()** que tambien es un array y asi evitariamos tener que escribir todos los campos
```php
        /*
        $curso = new Curso();
        $curso->name = $request->name;
        $curso->descripcion = $request->descripcion;
        $curso->categoria = $request->categoria;
        $curso->save();
        */
        // Lo anterior es igual a esto
        /*
        $cuso = Curso::create([
        'name' => $request->name,
        'descripcion' => $request->descripcion,
        'categoria' => $request->categoria
        ]);
        */
        // Lo anterior es igual a esto
        $cuso = Curso::create($request->all());
```

La asignación masiva por motivos de seguridad, y para evitar que otros usuarios creen nuevos campos con valores dados por ellos, requiere de la funcion fillable es decir llenable, esto se aplica a ciertos campos nada mas, es una forma de decirle que esta bien que se creen esos campos masivamente pero no otros, para poder aplicar esta funcion vamos a: App\Models\Curso ( O Modelo que se va a usar)
```php
<?php

class Curso extends Model
{
    use HasFactory;
    protected $fillable = ['name','descripcion','categoria'];
}
```
Otra opcion es evitar que ciertos campos no se creen por ejemplo un campo status, esto podemos conseguirlo agregando en lugar de la funcion $fillable, la funcion guarded
```php
<?php

class Curso extends Model
{
    use HasFactory;
    //rotected $fillable = ['name','descripcion','categoria'];
    protected guarded = ['status'];
}
```


Anteriormente usamos la asignación masiva con  el metodo create pero tambien es posible usar el metodo update, eso para funciones que ya tienen datos y lo que se desea es actualizar los valores

Continuacion del archivo CursoController.php
```php  
$curso->update($request->all());
return redirect()->route('cursos.show',$curso->id);
```

## Eliminar Registros
Lo primero es indicar la accion desde una URL es decir tengo que indicar que voy a eliminar, creamos la ruta para esto
```
Router::delete('cursos/{curso}',[CursoController::class, 'destroy'])->name('cursos.destroy');
```

Luego creamos la funcion en el controlador, por convención eliminar se llama destroy
```php
public function destroy(Curso $curso){
    $curso->delete();
    return redirect()->route('cursos.index');
}
```

## Route resources
Podemos ver las rutas asignadas desde la terminal usando el comando 
```
php artisan route:list
```
<pre>
+--------+----------+---------------------+----------------+----------------------------------------------+------------+
| Domain | Method   | URI                 | Name           | Action                                       | Middleware |
+--------+----------+---------------------+----------------+----------------------------------------------+------------+
|        | GET|HEAD | /                   |                | App\Http\Controllers\PageController          | web        |
|        | GET|HEAD | api/user            |                | Closure                                      | api        |
|        |          |                     |                |                                              | auth:api   |
|        | GET|HEAD | cursos              | cursos.index   | App\Http\Controllers\CursoController@index   | web        |
|        | POST     | cursos              | cursos.store   | App\Http\Controllers\CursoController@store   | web        |
|        | GET|HEAD | cursos/create       | cursos.create  | App\Http\Controllers\CursoController@create  | web        |
|        | GET|HEAD | cursos/{curso}      | cursos.show    | App\Http\Controllers\CursoController@show    | web        |
|        | PUT      | cursos/{curso}      | cursos.update  | App\Http\Controllers\CursoController@update  | web        |
|        | DELETE   | cursos/{curso}      | cursos.destroy | App\Http\Controllers\CursoController@destroy | web        |
|        | GET|HEAD | cursos/{curso}/edit | cursos.edit    | App\Http\Controllers\CursoController@edit    | web        |
+--------+----------+---------------------+----------------+----------------------------------------------+------------+
</pre>

Conocer y adaptarse a las convenciones ayuda a ahorrar tiempo a la hora de hacer muchas tareas, por ejemplo definir las rutas.

vamos a modificar el archivo routes/web.php para que en lugar de lucir asi:
```

Route::get('/', PageController::Class);

Route::get('cursos', [CursoController::Class, 'index'])->name('cursos.index');
Route::get('cursos/create', [CursoController::Class, 'create'])->name('cursos.create');
Route::post('cursos', [CursoController::Class, 'store'])->name('cursos.store');
Route::get('cursos/{curso}', [CursoController::Class, 'show'])->name('cursos.show');
Route::get('cursos/{curso}/edit', [CursoController::Class, 'edit'])->name('cursos.edit');
Route::put('cursos/{curso}', [CursoController::Class, 'update'])->name('cursos.update');
Route::delete('cursos/{curso}',[CursoController::class, 'destroy'])->name('cursos.destroy');
```
luzca asi
```
Route::get('/', PageController::Class);
Route::resource('cursos', CursoController::Class);    
```
La estructura recibe dos parametros, la url identificativa, en este caso cursos y el nombre del controlador esto hace que se tengan las mismas estructuras anteriores.

Supongamos que queremos queremos cambiar posteriormente el nombre de algunas de las urls, por ejmplo de **cursos/create** a **cursos/crear** 
Para eso vamos al archivo App/Providers/AppServiceProvider.php
incluimos la llamada a:
```
use Illuminate\Support\Facades\Route;
```

 Y en la funcion boot agregamos las lineas Route::resourceVerbs .... con las modificicaciones respectivas, indicando el nombre actual y el nombre que va a tomar
```
public function boot()
{
    Route::resourceVerbs([
        'create' => 'crear',
        'edit' => 'editar',
    ]);

    // ...
}
```

## Cambiando el nombre de la URL 
Supongamos ahora que queremos cambiar el nombre de la url de Cursos por ejemplo a Asignaturas
Para eso debemos cambiar el nombre en la ruta asi
```
Route::resource('asignaturas', CursoController::Class);
```
Esto convierte las rutas a la siguiente forma:
<pre>
+--------+-----------+---------------------------------+---------------------+----------------------------------------------+------------+
| Domain | Method    | URI                             | Name                | Action                                       | Middleware |
+--------+-----------+---------------------------------+---------------------+----------------------------------------------+------------+
|        | GET|HEAD  | /                               |                     | App\Http\Controllers\PageController          | web        |
|        | GET|HEAD  | api/user                        |                     | Closure                                      | api        |
|        |           |                                 |                     |                                              | auth:api   |
|        | GET|HEAD  | asignaturas                     | asignaturas.index   | App\Http\Controllers\CursoController@index   | web        |
|        | POST      | asignaturas                     | asignaturas.store   | App\Http\Controllers\CursoController@store   | web        |
|        | GET|HEAD  | asignaturas/crear               | asignaturas.create  | App\Http\Controllers\CursoController@create  | web        |
|        | GET|HEAD  | asignaturas/{asignatura}        | asignaturas.show    | App\Http\Controllers\CursoController@show    | web        |
|        | PUT|PATCH | asignaturas/{asignatura}        | asignaturas.update  | App\Http\Controllers\CursoController@update  | web        |
|        | DELETE    | asignaturas/{asignatura}        | asignaturas.destroy | App\Http\Controllers\CursoController@destroy | web        |
|        | GET|HEAD  | asignaturas/{asignatura}/editar | asignaturas.edit    | App\Http\Controllers\CursoController@edit    | web        |
+--------+-----------+---------------------------------+---------------------+----------------------------------------------+------------+

</pre>

Por ahora esto genera inconsistencias entre los nombres de rutas asignados y las llamadas a estas rutas en el codigo, para que funcione correctamente deberiamos conseguir que aunque las url hayan cambiado el nombre continue apuntando internamente a rutas con el prefijo cursos como **cursos.index** en lugar de asignaturas, para resolverlo definimos la ruta de la siguiente forma
```
Route::resource('asignaturas', CursoController::Class)->names('cursos');
```
Lo anterior resuelve la llamada interna a direcciones como cursos.index, cursos.create, cursos.show etc mientras en las URL se sigue haciendo referencia a asignaturas.

Otro problema que se desprende de esta modificación es los nombres de las variables esperadas, por ejemplo en algunos casos se pasan parametros con el nombre asignatura de la forma `/asignaturas{asignatura}` pero en muchos casos se recibe variables parametro {curso} el cual era la estructura antes de la modificación. esto puede corregirse redefiniedo el nombre de parametros. El metodo usado es el **parameters** que recibe un array con la url y el nombre que quiero dar
asi: parameters(['asignaturas'=>'curso'])
```
Route::resource('asignaturas', CursoController::Class)->parameters(['asignaturas'=>'curso'])->names('cursos');
```
haciendo esto podemos ver nuevamente el estado de las url
<pre>
dasesu@pchome:~/Desktop/Laravel$ php artisan r:l
+--------+-----------+----------------------------+----------------+----------------------------------------------+------------+
| Domain | Method    | URI                        | Name           | Action                                       | Middleware |
+--------+-----------+----------------------------+----------------+----------------------------------------------+------------+
|        | GET|HEAD  | /                          |                | App\Http\Controllers\PageController          | web        |
|        | GET|HEAD  | api/user                   |                | Closure                                      | api        |
|        |           |                            |                |                                              | auth:api   |
|        | GET|HEAD  | asignaturas                | cursos.index   | App\Http\Controllers\CursoController@index   | web        |
|        | POST      | asignaturas                | cursos.store   | App\Http\Controllers\CursoController@store   | web        |
|        | GET|HEAD  | asignaturas/crear          | cursos.create  | App\Http\Controllers\CursoController@create  | web        |
|        | GET|HEAD  | asignaturas/{curso}        | cursos.show    | App\Http\Controllers\CursoController@show    | web        |
|        | PUT|PATCH | asignaturas/{curso}        | cursos.update  | App\Http\Controllers\CursoController@update  | web        |
|        | DELETE    | asignaturas/{curso}        | cursos.destroy | App\Http\Controllers\CursoController@destroy | web        |
|        | GET|HEAD  | asignaturas/{curso}/editar | cursos.edit    | App\Http\Controllers\CursoController@edit    | web        |
+--------+-----------+----------------------------+----------------+----------------------------------------------+------------+
</pre>

## Pretty URLS
En el modelo creamos una tabla llamada `slug`, para eso vamos a database/migration y seleccionamos el archivo que nos interesa y agregamos en el un campo slug :
```php
    public function up()
    {
        Schema::create('cursos', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->string('slug');
            $table->text('descripcion');
            $table->text('categoria');
            $table->timestamps();
        });
    }
```

Luego vamos al Factory factorise/CursoFactory y modificamos la definición  agregando un helper que va a reemplazar espacios por guiones: 
Debemos incluir en el archivo la llamada a Illuminate\Support\Str
```php
use Illuminate\Support\Str
...

    
    public function definition()
    {
        $name = $this-> faker->sentence();
        return [
            'name' => $name,
            'slug' =>  Str::slug($name, '-'),
            'descripcion' => $this-> faker-> paragraph(),
            'categoria' => $this-> faker-> randomElement(['Desarrollo Web','Diseño Web'])
        ];
    }
```

Luego realizamos la migracion con 
```
php artisan migrate:fresh --seed
```

Hasta ahora se ha creado el slug correctamente en base de datos, pero no le he indicado a Laravel que use el campo slug para recuperar el objeto tal como hace con el id, basicamente latex hace algo parecido a Curso::find($curso) donde curso es una id, pero si le digo que busque por otro campo que no vaya a repetirse, laravel deberia resolver la misma situación, para hacer esto vamos al modelo Curso en App/Models/Curso.php . ese objeto hereda de Illuminate\Database\Eloquent\Model que contiene metodos que definen el comportamiento de los modelos para laravel, alli buscamos la función  getRouteKeyname()
```php
    public function getRouteKeyName()
    {
        return $this->getKeyName();
    }
```

getKeyName le indica a Laravel que tome il Id como clave para definir la url, si cambio el contenido a la siguiente forma, las urls se generarian por el slug y no mas por el id. Para conseguir las urls amigables no vamos a reemplazar codigo de latex, pero vamos a reescribir esa funcion dentro de nuestro modelo Curso.
```php
    public function getRouteKeyName()
    {
    //    return $this->getKeyName();
          return 'slug';
    }
```

Model\Curso.php
```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Curso extends Model
{
    use HasFactory;
    protected $fillable = ['name','descripcion','categoria'];

    public function getRouteKeyName()
    {
        return 'slug';
    }
    
}
```

Esto deja un problema presente y es que cuando se crean nuevos Cursos no se está creando el slug correspondiente, una solución es crear el campo slug en el formulario, una mejor idea es usar una función que autogenere el nombre del campo automaticamente y lo muestre al usuario, para que el usuario no tenga que reescribir la url que va a quedar.

Otra solución puede ser modificar el Controlador para que tome la variable antes de crearla en el modelo y cree el campo slug de la siguiente forma:
```php
public function store(Request $request)
    {

        
        $curso = new Curso();
        $curso->name = $request->name;
        $curso->slug = Str::slug($request->name, '-');
        $curso->descripcion = $request->descripcion;
        $curso->categoria = $request->categoria;
        $curso->save();

``` 
Un problema con la solución anterior es que nuevamente la variable $request es del tipo Request y no del tipo StoreCurso, asi que  se pierde la posibilidad de hacer asignación masiva.
 Mas adelante se veran otras soluciones para esto.

## Navegavilidad

Para poder accionar segun la url en la que nos encontremos necesitamos un metodo que nos permita preguntar donde estamos, laravel provee este metodo, en nuetra vista \*.blade.php , la funcion routeIs devuelve true si me encuentro en la url que le paso por parametro y false en caso contrario
```
<?php
    dump(request()->routeIs('home')); 
?>
```

Blade además me permite abreviar un poco esa instruccion asi
```
@dump(request()->routeIs('home')); 
```

Usando estilos usariamos esto de esta forma
```css
<class={ { request()->routeIs('home') ? 'active' : '' } } // esto es como preguntar if 'active' else ''
```

Con esto en mente podemos agregar estilos y mostrar lo que queramos segun la url en la que nos encontremos, el metodo routeIs puede ademas recibir parametros de la forma ('cursos.\*') es decir cualquier pagina que tenga empiece por cursos.


## Incluir archivos  en blade
Supongamos que queremos separar la estructura de una plantilla en header, body, footer, creamos estos archivos en views/layouts/partials/ y alli creamos archivos header, body, footer, para llamar header por ejemplo desde plantilla.blade.php usamos la primitiva @include() y debemos indicarle la ruta donde se encuentra el archivo a incluir, viendola partiendo de la carpeta views asi:
```
@include('layout.partials.header')
```


## Enviar Emails:
Conectarnos con proveedor de correo electronico, por ejemplo Gmail  es decir SMTP
Para configurar  el proyecto laravel para que nos permita enviar correos electronicos desde  una cuenta SMTP tenemos que ir al archivo **config/mail.php** estos archivos de configuración suelen tomar muchas variables del archivo ENV en su defecto toma a configuración definida en el archivo mail.php 

Para pruebas usamos [mailtrap.io](mailtrap.io) 

dentro de las opciones tengo un correo de pruebas entre las opciones de lenguaje o tecnologia aparecen las de laravel
<pre>
MAIL_MAILER=smtp
MAIL_HOST=smtp.mailtrap.io
MAIL_PORT=2525
MAIL_USERNAME=17ae643a49da25
MAIL_PASSWORD=c316a1953dc441
MAIL_ENCRYPTION=tls
</pre>

Para poder enviar un email creamos un mailable
``` 
php artisan make:mail ContactanosMailable
``` 

El comando anterior crea un archivo **Mail/ContactanosMailable.php** dentro de la carpeta App 
```php
<?php

namespace App\Mail;

use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Mail\Mailable;
use Illuminate\Queue\SerializesModels;

class ContactanosMailable extends Mailable
{
    use Queueable, SerializesModels;

    /**
     * Create a new message instance.
     *
     * @return void
     */
    public function __construct()
    {
        //
    }

    /**
     * Build the message.
     *
     * @return $this
     */
    public function build()
    {
        return $this->view('view.name');
    }
}

```

En este archivo podemos agregar vistas e información por ejemplo el **subject**, y el contenido del email. La funcion build retorna una vista, tal como si de un controlador se tratase carga la vista posteriormente para enviarla al correo, estas vistas tambien son del tipo blade.php y se cren dentro de la carpeta viwes, por ejemplo si creamos una vista dentro del **emails** llamada **contactanos.blade.php** en la funcion build la llamariamos $this->view('**emails.contactanos**'), estos cambios basicos lucirian asi:

```php
<?php

namespace App\Mail;

use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Mail\Mailable;
use Illuminate\Queue\SerializesModels;

class ContactanosMailable extends Mailable
{
    use Queueable, SerializesModels;
    public $subject = "información de contacto";
    /**
     * Create a new message instance.
     *
     * @return void
     */
    public function __construct()
    {
        //
    }

    /**
     * Build the message.
     *
     * @return $this
     */
    public function build()
    {
        return $this->view('emails.contactanos');
    }
}

```


El archivo contactanos.blade.php contiene un archivo html por ejmplo asi:

```html
<!DOCTYPE html>
<html>
<head>
    <title>contactanos</title>
</head>
<body>
    <h1>Correo Electronico</h1>
    <p>Este es el primer correo que mandaré por laravel</p>
</body>
</html>
```

Para enviar el correo creo por ejemplo una ruta dentro de **routes/web.php** debo incluir las llamadas 
```
use App\Mail\ContactanosMailable;
use Illuminate\Support\Facades\Mail;
```

y luego crea una instancia de `ContactanosMailable` , y definimos con la clase mail a quien enviaremos el correo junto con el correo.
```php
 $correo = new ContactanosMailable;
    Mail::to('dasesumail@gmail.com')->send($correo);
    return "mensaje enviado";
``` 

El archivo de rutas quedaria asi, pero por supuesto esto podria llevarse a un controlador:
```php
<?php

use Illuminate\Support\Facades\Route;
use App\Http\Controllers\PageController;
use App\Http\Controllers\CursoController;

use App\Mail\ContactanosMailable;
use Illuminate\Support\Facades\Mail;

Route::get('/', PageController::Class)->name('home');

Route::resource('cursos', CursoController::Class);

Route::get('contactanos', function(){
    $correo = new ContactanosMailable;
    Mail::to('dasesumail@gmail.com')->send($correo);
    return "mensaje enviado";
});
```

## enviando mensajes desde un formulario

Creamos un controlador llamado ContactanosController, alli creo dos funciones una index que se va a encargar de llamar a la vista y una store que se va a encargar de procesar el envio

```php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

# Mail 
use App\Mail\ContactanosMailable;
use Illuminate\Support\Facades\Mail;

class ContactanosController extends Controller
{
    public function index(){
        return view('contactanos.index');
    }
    
    public function store()
    {
        $correo = new ContactanosMailable;
        Mail::to('dasesumail@gmail.com')->send($correo);
        return "mensaje enviado";
    }

}
```

Modificamos nuestro archivo de ruta para que la funcion se encuentre en el controlador y no en las rutas:

```php
<?php

use Illuminate\Support\Facades\Route;
use App\Http\Controllers\PageController;
use App\Http\Controllers\CursoController;
use App\Http\Controllers\ContactanosController;

Route::get('/', PageController::Class)->name('home');

Route::get('cursos', [CursoController::Class, 'index'])->name('cursos.index');
Route::get('cursos/create', [CursoController::Class, 'create'])->name('cursos.create');
Route::post('cursos', [CursoController::Class, 'store'])->name('cursos.store');
Route::get('cursos/{curso}', [CursoController::Class, 'show'])->name('cursos.show');
Route::get('cursos/{curso}/edit', [CursoController::Class, 'edit'])->name('cursos.edit');
Route::put('cursos/{curso}', [CursoController::Class, 'update'])->name('cursos.update');
Route::delete('cursos/{curso}',[CursoController::Class, 'destroy'])->name('cursos.destroy');

Route::get('contactanos', [ContactanosController::Class, 'index'])->name('contactanos.index');
```

y creamos la vista dentro **/resources/views/contactanos/indx,blade.php
```html
@extends('layouts.plantilla')

@section('title','Contactanos')

@section('content')
<?php echo "<h1>Dejanos un mensaje</h1>"; ?>

<form action=" { {route('contactanos.store')} }" method="post">
    
    @csrf

    <label>
        Nombre:
        <br>
        <input type="text" name="name">
        <br>
    </label>

    <label>
        Correo:
        <br>
        <input type="text" name="correo">
        <br>
    </label>

    <label>
        Mensajes:
        <br>
        <textarea name="mensaje" rows=4></textarea>
        <br>
    </label>

    <button type="submit">Enviar mensaje</button>
    
</form>

@endsection
```
Este formulario se envia a la función contactanos.store  pero debemos aregar la ruta en web.php  
```php
<?php
...
Route::get('contactanos', [ContactanosController::Class, 'index'])->name('contactanos.index');
Route::post('contactanos', [ContactanosController::Class, 'store'])->name('contactanos.store');
```
Y modificamos la función contactanos.store para que sea capaz de recibir esos campos y reenviarlos a  ContactanosMailable.php
```php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

# Mail 
use App\Mail\ContactanosMailable;
use Illuminate\Support\Facades\Mail;

class ContactanosController extends Controller
{
    public function index(){
        return view('contactanos.index');
    }
    
    public function store(Request $request)
    {
        $correo = new ContactanosMailable($request->all());
        Mail::to('dasesumail@gmail.com')->send($correo);
        return "mensaje enviado";
    }

}
```
y en el constructor de la función ContactanosMailable.php recibimos esos datos quedando asi
```php
<?php

namespace App\Mail;

use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Mail\Mailable;
use Illuminate\Queue\SerializesModels;

class ContactanosMailable extends Mailable
{
    use Queueable, SerializesModels;

    public $subject = "información de contacto";
    public $contacto;
    /**
     * Create a new message instance.
     *
     * @return void
     */
    public function __construct($contacto)
    {
        $this->contacto = $contacto;
    }

    /**
     * Build the message.
     *
     * @return $this
     */
    public function build()
    {

        return $this->view('emails.contactanos');
    }
}

```
En el codigo anterior recuperamos los campos del formulario por la variable $contacto, que a su vez se encuentra definida en la clase de forma publica asi, al reescribir el contenido de la variable con el `$this->contacto = $contacto` recibe lo que recibiimos del formulario, luego desde **emails.contactanos** podemos enviar cada dato de este arreglo de valores asi:
```php
{ { $contacto['name'] } }
{ { $contacto['correo'] } }
{ { $contacto['mensaje'] } }
```

Para mejorar esto podriamos agregar un validate al formulario en el contactanos.store
```php

    
    public function store(Request $request)
    {
        $request->validate([
            'name' => 'required',
            'correo' => 'required|email',
            'mensaje' => 'required'
        ]);
        $correo = new ContactanosMailable($request->all());
        Mail::to('dasesumail@gmail.com')->send($correo);
        return "mensaje enviado";
    }

```
luego en el formulario mostramos los posibles mensajes de error para cada uno de los campos
```
@error('name')
    { { $message } }
@enderror
```

Ahora para que en lugar de llevarnos a una pagina en blanco que nos diga mensaje enviado, aparezca una alerta o un mensaje en la misma pagina del formulario 

Para eso vamos a pedirle que nos redireccione a la ruta contacto.index pero ademas le vamos a pasar un mensaje de sesion **return redirect()->route('contactanos.index')->with('info','mensaje enviado')**

```php
...
'correo' => 'required|email',
            'mensaje' => 'required'
        ]);
        $correo = new ContactanosMailable($request->all());
        Mail::to('dasesumail@gmail.com')->send($correo);
        return "mensaje enviado";
    }

    return redirect()->route('contactanos.index')->with('info','mensaje enviado');
```

y luego hay que capturar esto desde contactanos.index asi::
```php
@if( session('info'))
    <script>
        alert("{ { session('info') } }");
    </script>
@endif
```


## Técnicas de Autenticación en Laravel

* En las primeras versiones de laravel para tener un sistema de autenticación habia que crearlo manualmente,
versiones 3 y 4, eso incluye vistas rutas y controladores

* En la version Laravel incluye un sistema que usaba bootstrap y blade, y permitia el manejo login logout y reseteo de contraseñas

* version 5.1 se hizo opcional y podia llamarse a esto usando 
```php
php artisan make:auth
```

* En la vesión 6 se elimino el sistema de autenticación pero en su lugar se creó el paquete laravel/ui

* en la versión se introduce el paquete opcional jetstream


<p align="center">
<img src="{{site.baseurl}}/assets/img/posts/{{page.relatives}}/laravelui.png?raw=true">
</p>

<p align="center">
<img src="{{site.baseurl}}/assets/img/posts/{{page.relatives}}/laravelBreeze.png?raw=true">
</p>

<p align="center">
<img src="{{site.baseurl}}/assets/img/posts/{{page.relatives}}/laravelFortify.png?raw=true">
</p>

<p align="center">
<img src="{{site.baseurl}}/assets/img/posts/{{page.relatives}}/laravelJetstream.png?raw=true">
</p>

<p align="center">
<img src="{{site.baseurl}}/assets/img/posts/{{page.relatives}}/LaravelSanctum.png?raw=true">
</p>

<p align="center">
<img src="{{site.baseurl}}/assets/img/posts/{{page.relatives}}/autenticacionresumen.png?raw=true">
</p>

## Breeze
```
composer  create-project laravel/laravel laravel-breeze

modificamos .env para conectar con la base de datos
php artisan migrate

composer require laravel/breeze --dev
php artisan breeze:install
```

## Verificación de email y como personalizarla
Para implementar la verificación de cuenta por email tenemos que hacer que el modelo User herede de 
MustVerifyEmail, para hacerlo vamos al modelo user y agregamos ` implements MustVerifyEmail` a la clase asi:

```php
<?php

namespace App\Models;

use Illuminate\Contracts\Auth\MustVerifyEmail;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;

class User extends Authenticatable implements MustVerifyEmail
{
    use HasFactory, Notifiable;

    /**

```

Agregamos las credenciales de mailtramp para poder hacer el envio del email  en el archivo .env asi 
```php
MAIL_MAILER=smtp
MAIL_HOST=smtp.mailtrap.io
MAIL_PORT=2525
MAIL_USERNAME=17ae643a49da25
MAIL_PASSWORD=c316a1953dc441
MAIL_ENCRYPTION=tls
MAIL_FROM_ADDRESS=dasesumail@gmail.com
```

Y para que el usuario antes de acceder a la ruta tenga que verificar su cuenta agregamos el middleware verified a la ruta asi 
```php
Route::get('/dashboard', function () {
    return view('dashboard');
})->middleware(['auth','verified'])->name('dashboard');
```

Opciones que permite breeze son: modificar la cantidad de intentos fallidos antes de ejecutar otra accion, se pueden personalizar los mensajes, entre otras

En jetstream que usa fortify 
Open config/fortify.php file and uncomment the Features::emailVerification(), line.
```
'features' => [
    Features::registration(),
    Features::resetPasswords(),
    // Features::emailVerification(),
    Features::updateProfileInformation(),
    Features::updatePasswords(),
    Features::twoFactorAuthentication([
        'confirmPassword' => true,
    ]),
],
```


## Confirmación por contraseña
Esto consist en que ciertas tareas delicadas pueden requerir que el usuario introduzca nuevamente su contraseña

Ejemplo:
en el archvivo `resources/views/layout/navigation`  duplicamos el link de navegación que aparece

```php

      <!-- Navigation Links -->
      <div class="hidden space-x-8 sm:-my-px sm:ml-10 sm:flex">
          <x-nav-link :href="route('dashboard')" :active="request()->routeIs('dashboard')">
              { { __('Dashboard') } }
          </x-nav-link>
      </div>
      <div class="hidden space-x-8 sm:-my-px sm:ml-10 sm:flex">
          <x-nav-link :href="route('super-secret')" :active="request()->routeIs('super-secret')">
              { { __('Secret Page') } }
          </x-nav-link>
```

Agrego tambien los links responsivos, luego de eso agrego la ruta a `routes/web.php`
```php
Route::view('/super-secret', 'secret')->name('super-secret');
```

y creo la vista en `resources/view/secret.blade.php`

con el contenido 
```php
<x-app-layout>
    <x-slot name="header">
        <h2 class="font-semibold text-xl text-gray-800 leading-tight">
            { { __('Secret Page') } }
        </h2>
    </x-slot>

    <div class="py-12">
        <div class="max-w-7xl mx-auto sm:px-6 lg:px-8">
            <div class="bg-white overflow-hidden shadow-sm sm:rounded-lg">
                <div class="p-6 bg-white border-b border-gray-200">
                    The secret page
                </div>
            </div>
        </div>
    </div>
</x-app-layout>

```

Para proteger la ruta con contraseña basta con agregar el middleware 
```php
Route::view('/super-secret', 'secret')->name('super-secret')->middleware('password.confirm');
```

## Jetstream

Composer
```php
composer create-project laravel/laravel blog
composer require laravel/jetstream
php artisan jetstream:install livewire
npm install
npm run dev
php artisan migrate
```




## Componentes de Blade
[https://dev.to/bobriksantiago/componentes-laravel-7-3lnm](https://dev.to/bobriksantiago/componentes-laravel-7-3lnm)

Crear componente 
```
php artisan make:component Alert
```

Este comando crea 2 archivos uno se encuentra en resources/views/components/alert.blade.php y el segundo archivo es una clase que se encuentra en app/view/Components/Alert.php

dentro de la vista alert.blade.php agregamos
```html
<div class="bg-{ {$color}}-200 border border-{ {$color}}-500 text-{ {$color}}-800 px-4 py-3 rounded relative" role="alert">
  <strong class="font-bold">Holy smokes!</strong>
  <span class="block sm:inline">Something seriously bad happened.</span>

  <span class="absolute top-0 bottom-0 right-0 px-4 py-3">
    <svg class="fill-current h-6 w-6 text-{ {$color}}-500" role="button" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><title>Close</title><path d="M14.348 14.849a1.2 1.2 0 0 1-1.697 0L10 11.819l-2.651 3.029a1.2 1.2 0 1 1-1.697-1.697l2.758-3.15-2.759-3.152a1.2 1.2 0 1 1 1.697-1.697L10 8.183l2.651-3.031a1.2 1.2 0 1 1 1.697 1.697l-2.758 3.152 2.758 3.15a1.2 1.2 0 0 1 0 1.698z"/></svg>
  </span>

</div>
```

en el archivo welcome..blade.php 
```html
...
        <link rel="stylesheet" href="{ {asset('css/app.css')}}">
        <!-- Styles -->
        
    </head>
  <body>
    <div class="container mx-auto" >
        
        
        <x-alert />
        
    </div>
  </body>
```

Esto llama al componente desde  app/view/Components/Alert.php
```php
<?php

namespace App\View\Components;

use Illuminate\View\Component;

class Alert extends Component
{
    /**
     * Create a new component instance.
     *
     * @return void
     */
    public function __construct()
    {
        //
      
    }

    /**
     * Get the view / contents that represent the component.
     *
     * @return \Illuminate\Contracts\View\View|\Closure|string
     */
    public function render()
    {
        return view('components.alert');
    }
}
```

para usar el componente creamos etiquetas con la forma x-nombreComponente asi
``` 
<x-alert /> 
``` 

Podemos pasar atributos  que luego podemos recuperar desde la clase Alert usando el mismo nombre.
```
 <x-alert price="$400"  name="Candy" />
```

Si quiero usar variables como atributo le indico a laravel agregando el prefijo `:` asi:
```
<x-product :price="$price" :name="$name"/>
```

Una variable particular es creada cuando creamos la etiqueta de con su respectivo cierre, y cualquier cosa que escriba dentro va a almacenarse en una variable llamada slot
asi 
```
<x-alert> 
  Este es el contenido de una variable slot
</x-alert> 
```

Existe otra variable definida como slot con nombre 
```
<x-alert> 
  <x-slot name="title">
  </x-slot>
  Este es el contenido de una variable slot
</x-alert> 
```

Para recuperar el contenido de esa variable simplemente accedemos al nombre del atributo en este caso title asi
``` 
el titulo es: { { $title}}
```


Si se recibe una clase en el componente la manera correcta es fusionar el contenido de esa clase con una clase en la vista asi
incluyendo en la clase de la vista la variable usando el metodo merge() de algo asi 
```

<div class="alert" class="mb-4">
    { { $slot }}
</div>

``` 

a algo asi
```
<div { { $attributes->merge(['class' => 'alert']) }}>
    { { $slot }}
</div>
```
Puede verse mejor aqui [https://www.amitmerchant.com/merge-attributes-blade-components-laravel7/](https://www.amitmerchant.com/merge-attributes-blade-components-laravel7/)

## laravel permite definir componentes anónimos
Se crean agregando la vista con la setructura del componente a resources/view/components/ por ejemplo resources/view/components/alert2.blade.php luego podemos llamarlo usando la etiqueta `<x-alert2 />` sin haber definido la clase, pque pasa si quiero enviar una variable como color? en la vista, defino la etiqueta igual que hice antes 
```
 <x-alert2 color="red" />
```

Para poder recuperarla desde la vista, ya uqe no tenemos la clase incluimos ne la vista una directiva `@prosp` donde incluimos los nombres de las variables que queremos usar asi
``` 
@prosp([`color`])

Ahora si puedo usar la variable en la vista asi
{ {$color}}
``` 



## Componentes dinamicos 
Se definen con  `<x-dynamic-component>` se usan asi:
```
<x-dynamic-component :component="$variable">
  <x-slot name="title">
    este es el titulo
  </x-slot>
  Este es el contenido de una variable slot
</x-dynamic-component>
```



## Copiar componentes de jetstream a mi proyecto

La idea es copiar los componentes que se encuentran en las vistas de jetstream pero no del proyecto al proyecto para poder hacer modificaciones sin tener que comprometerlas en caso de actualizaciones, estas se copian desde /vendor/laravel/jetstream/resources/views a  /resources/views/vendor/jetstream
```
php artisan vendor:publish --tag=jetstream-views
```

## Middleware
Supongamos que quiero crear un middlerware que verificque la edad, el siguiente comando crea un archivo dentro de App/Http/Middlewares/CheckAge
```
php artisan make:middleware CheckAge
```

Para poder usarlo debemos registrarlo primero, agregandolo a App/Http/Kernels.php en la sección $routMiddleware asi
```
...
     */
    protected $routeMiddleware = [
        'auth' => \App\Http\Middleware\Authenticate::class,
        'auth.basic' => \Illuminate\Auth\Middleware\AuthenticateWithBasicAuth::class,
        'cache.headers' => \Illuminate\Http\Middleware\SetCacheHeaders::class,
        'can' => \Illuminate\Auth\Middleware\Authorize::class,
        'guest' => \App\Http\Middleware\RedirectIfAuthenticated::class,
        'password.confirm' => \Illuminate\Auth\Middleware\RequirePassword::class,
        'signed' => \Illuminate\Routing\Middleware\ValidateSignature::class,
        'throttle' => \Illuminate\Routing\Middleware\ThrottleRequests::class,
        'verified' => \Illuminate\Auth\Middleware\EnsureEmailIsVerified::class,
        'age' => \App\Http\Middleware\CheckAge::class,
    ];
```

para incluirlo en la ruta lo agregamos al final asi 
```
Route::get('prueba', function(){
  return "Has accedido correctamente a esta ruta";
})->middleware('age');
``` 

## BASE DE DATOS
Para crear tablas desde laravel creo primero la migración, para eso hago
```
php artisan make:migration create_profiles_table
```

y creamos tambien el modelo que se va a encargar de crear la tabla 
```
php artisan make:model Profile
```
En la migración agregamos los campos que deseamos que tenga con los atributos que deseamos que tenga  por ejemplo 
``` 
$table->id();
$table->string('title',45);
$table->text('biografia');
$table->string('website',45);
``` 

Para agregar claves foraneas agregamos los campos
```
$table->unisgnedBigInteger('userid')->unique();
$table->foreign('user_id')->reference('id')->on('users')->onDelete('cascade'); // cascade o set null
```

Cascade Elimina los datos que contienen claves foraneas set null asigna el campo null donde se encontraba la clave foranea, pero si vamos a usar set null debemos indicar la ocion nulleable


## relaciones ONO A UNO
Supongamos que tengo una tabla usuario y un perfil, esta es una relacion uno a uno y la entidad fuerte es usuario. Recordemos que las entidades fuertes son las que en una relacion no dependen de la existencia de la otra entidad, mientras que la debil si, en este tipo de relacion la entidad debil es quien absorve la clave foreanea. ahora supongamos que quiero tener los datos de la tabla perfil a partir del id del usuario, es decir con el usuario del id busco la clave foranea en perfiles y tengo los datos

para esto modificamos el modelo Users y agregamos un metodo que llamamos profile, este metodo va a recuperar la información del perfil tengo varias formas de hacer eso
```
    public function profile(){
    //    $profile =  Profile::where('user_id', $this->id)->first();
    //    return $this->hasOne(profile::class); // Esto requiere que importemos la ruta \App\Models\Profile
        return $this->hasOne('\App\Models\Profile'); // Esto requiere que importemos la ruta \App\Models\Profile

        
    }
``` 

Si no seguimos la convención y la clave foranea no se llama user_id supongamos que la llamamos foranea_id deberiamos indicarle el nombre como un segundo parametro igualmnte si la clave primaria en la tabla referenciada no la llamamos id sino de otra forma incluimos un tercer parametro con ese nombre asi
```
    return $this->hasOne('\App\Models\Profile','foranea_id', 'local_id'); 
```

Si quisieramos llevar a cabo el proceso contrario, es decir recuperar los campos de usuario a partir del profile hariamos lo  mismo, vamos al profile y creamos un metodo user asi:
``` 
// Models\Profile.php
public function user(){
      //$user = User::find($this->user_id);

      return $this->belongsTo('\App\Models\User'); // proceso analogo al hasOne
    }
``` 

## Relaciones UNO A MUCHOS
En situaciones donde la entidad debil depende de dos entidades fuertes creamos primero las entidades fuertes 
Por ejemplo tenemos la tabla usuarios, y la tabla categorias, supongamos que queremos crear una tabla posts que depende de ambas, es decir un post lo hace un usuario y pertenece a una determinada categoria. La tabla usuario ya la tenemos ahora creamos la entidad categorias. el parametro -m ademas de crear el modelo crea tambien la migración
``` 
php artisan make:model Categoria -m 
```
Para que se cree el controlador pasamos el parametro: **c**
Para que se cree el seeder  pasamos el parametro: **s**
Para que se cree el factory  pasamos el parametro: **f**
y si queremos que se creen todas estas opciones usamos el parametro: **a**

Una vez creada la migración categorias agregamos los campos, en este caso es el campo name, los otros campos ya se encuentran en la migración asi 
```
Schema::create('categorias', function (Blueprint $table) {
            $table->id();
            $table->string('name',45);
            $table->timestamps();
        });
```

Luego hago lo mismo para crear la entidad Post
```
php artisan make:model Categoria -m 
```

En la migracion de categorias agregamos los campos
```php
public function up()
    {
        Schema::create('posts', function (Blueprint $table) {
            $table->id();

            $table->string('name');
            $table->text('body');
            $table->unsignedBigInteger('user_id')->nullable();
            $table->unsignedBigInteger('categoria_id')->nullable();

            $table->foreign('user_id')->references('id')->on('users')->onDelete('set null');

            $table->foreign('categoria_id')->references('id')->on('categorias')->onDelete('set null');

            $table->timestamps();
        });
    }
```
Con esto tenemos la reacion muchos a muchos en la base de datos, ahora creemos crear las operaciones eloquent en los modelos

Primero vamos al modelo User y agregamos
```php
    public function posts(){
        return $this->hasMany('App\Models\Post');
    }
```

Luego vamos a Post para hacer la relacion inversa y alli agregamos el metodo
```php
    // Relacion uno a muchos (inversa)
    public function user(){
      return $this->belongsTo('App\Models\User');
    }
```
Notese que al llamar a la función muchos posts tienen un usuario y se respeta la convención nombrando la función en singular (user)

Repetimos el proceso entre Categoria y post asi
```php
// Archivo: Models/Categoria.php 
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Categoria extends Model
{
    use HasFactory;

    // Relacion uno a muchos
    public function posts(){
      return hasMAny('App\Models\Post');
    }
}

``` 

```php
// Archivo: Models/Post.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Post extends Model
{
    use HasFactory;

    // Relacion uno a muchos (inversa)
    public function user(){
      return $this->belongsTo('App\Models\User');
    }

    // Relacion uno a muchos (inversa)
    public function categoria(){
      return $this->belongsTo('App\Models\Categoria');
    }
}
```

Luego hacemos la migracion correspondiente
```
php artisan migrate
```

Despues de esto agregamos algunos datos de prueba y abrimos la terminal de tinker
```
php artisan tinker
use App\Models\User;
$user = User::find(1);
$user->posts;
```

Podemos hacer lo mismo con las categorias, es decir listar los posts dada una categoria 
```
php artisan tinker
use App\Models\Categoria;
$categoria = Categoria::find(1);
$categoria->posts;
```


## Relaciones Muchos a Muchos
Por convención las relaciones muchos a muchos usan una tercera tabla con el nombre combinado de ambas en singular y en orden alfabetico, por ejemplo si queremos crear la relación entre Usuarios y Roles la relación quedaría `role_user` 

Vamos a ver esto:
```
php artisan make:model Role -m
```

agregamos un campo nombre a la migración
```php
    public function up()
    {
        Schema::create('roles', function (Blueprint $table) {
            $table->id();

            $table->string('name',45);
            
            
            $table->timestamps();
        });
    }
```

Luego creamos la relación role user, recordemos que ya teniamos la tabla User
```
php artisan make:migration create_role_user_table
```

y agrego las claves foraneas con sus restricciones
```php
    public function up()
    {
        Schema::create('role_user', function (Blueprint $table) {
            $table->id();

            $table->unsignedBigInteger('role_id');
            $table->unsignedBigInteger('user_id');

            $table->foreign('role_id')->references('id')->on('roles')->onDelete('cascade');
            $table->foreign('user_id')->references('id')->on('users')->onDelete('cascade');

            $table->timestamps();
        });
    }
```

Luego debemos crear la migración a nivel de modelos, En los modelos User y Role agregamos los metodos roles y users respectivamente
```php
// Modelo User.php
    // Relaciones MUCHOS A MUCHOS
    public function roles(){
        return $this->belongsToMany('App\Models\Role');
    }   

```

```php
// Modelo Role.php
    // Relaciones MUCHOS A MUCHOS
    public function users(){
        return $this->belongsToMany('App\Models\User');
    }   

```

Vamos a suponer que tengo 3 roles, administrador, editor y player, con ids 1,2 y 3 respectivamente, si quiero que los usuarios se agreguen a estos roles desde los modelos puedo hacerlo usando los metodos attach y detach para eliminarlo, veamos un ejemplo en tinker:
```
>>> use App\Models\User;
>>> $user = User::find(1);
=> App\Models\User {#3593
     id: 1,
     name: "Sebastian",
     email: "dasesumail@gmail.com",
     email_verified_at: null,
     #password: "$2y$10$jLK/CErwfdz2m7JZ06nCrejGCGuw7
...
$user->roles()->attach(1); // esto lo que hace es que agrega el role con id 1 al usuario ( con id 1 )
$user->roles()->attach(2); // esto lo que hace es que agrega el role con id 2 al usuario ( con id 1 )

$user->roles()->detach(2);
```

La función attach y detach puede recibir tambien arrays de la forma `$user->roles()->detach([1,2,3]);`
Existe un metodo que permite definir los roles sin importar roles previos este es el metdoo sync, recibe un arreglo de los ids que va a conservar y el resuelve las diferencias asi
```
    $user->roles()->sync([1,2]); 
```

## Relaciones Uno a Uno Polimorficas
El objetivo de las relaciones polimorifcas es poder crear una tabla que pueda ser relacionada desde diferentes tablas, asi deberiamos identificar si se esta llamando un "recurso" desde usuarios, desde "post" o desed algun otro recurso, en este caso son relaciones uno a uno asi que tambien podemos usar la composición de ciertos campos como Id de la relación,

Para hacer esto por convención se crean 2 campos, el primero de estos campos debe llevar el nombre de la tabla con terminación `able` seguido del id y lo mismo ocurre con el segundo campo pero seguido de type, por ejemplo para la tabla imagen seria asi

images:
id, url, imageable_id, imageable_type

en el campo imageable_id seria el id foraneo de la tabla que la llama, y el imageable_type seria el modelo que lo llama

Vamos a ver este ejemplo, para eso vamos a crear el modelo y migración de la tabla images
```php
php artisan make:model Image -m
```

y en la migración agregamos los siguientes campos 
```php
    public function up()
    {
        Schema::create('images', function (Blueprint $table) {
            
            $table->string('url');            

            $table->unsignedBigInteger('imageable_id');
            $table->string('imageable_type');            

            $table->primary(['imageable_id','imageable_type']);

            $table->timestamps();
        });
    }
```

hacemos la migración
``` 
php artisan migrate
``` 

Ahora vams a definir la relación a nivel de modelos
debemos agregar una función con el mismo nombre del prefijo usado en los campos que definen el polimorfismo, en este caso `imageable`, y usamos la operación morphTo para indicar que es una relación polimorfica ademas dejamos vació el parametro pues va a variar segun quien lo llame.

```php
// Modelo Image
    public function imageable(){
      return $this->morphTo();
    }
```

Ahora debemos ir al modelo o los modelos que van a llamar estos recursos, pro ejemplo el modelo User y agregamos
```php
// Modelo User
    // Relación uno a uno Polimofica
    public function image(){
        return $this->morphOne('App\Models\Image', 'imageable');
    }
```
```php
    // Relación uno a uno Polimofica
    public function image(){
        return $this->morphOne('App\Models\Image', 'imageable');
    }
```

Vamos a probar esto pero antes permitimos la asignación masiva el modelo Image, para eso agregamos la instrucción `protected $guarded = [];`
```php
class Image extends Model
{

    // Permite la asignación masiva
    protected $guarded = [];

    use HasFactory;
....
``` 

Ahora desde Tinker hacemos
```
>>> use App\Models\Image;
>>> Image::create(['url' => 'url 1', 'imageable_id' => 1,  'imageable_type' => 'App\Models\User']);
``` 

La consulta anterior es poco automatizable y poco legible, hay una forma parecida a los metodos attach y detach para hacer lo mismo que lo anterior desde el Modelo User o el Modelo Post
```php
>>> use App\Models\User;
>>> $user = User::find(1);
>>> $user->image()->create(['url' => 'url 1']);
```

## Relaciones UNO A MUCHOS polimorfica
Supongamos que quiero almacenar los comentarios en una tabla, pero puedo tener comentarios de posts, y puedo tener comentarios de videos, en este caso un mismo comentario podría tenerlo en varios posts, y un post puede tener varios comentarios, de igual manera ocurre con Videos, en este caso la relación se describe como muchos a muchos.

vamos a crear la tabla para comentarios

```
php artisan make:model Comment -m
```

Luego en la migracion agregamos 
```php
    public function up()
    {
        Schema::create('comments', function (Blueprint $table) {
            $table->id();

            $table->string('mensaje');
            
            $table->unsignedBigInteger('commentable_id');
            $table->string('commentable_type');          

            $table->unsignedBigInteger('user_id');
            $table->foreign('user_id')->references('id')->on('users')->onDelete('cascade');

            $table->timestamps();
        });
    }
```

Ya relacionados  a nivel de migración vamos a relacionarlo a nivel de modelos
abrimos los modelos Comments, Posts, Videos

en el modelo Comment agregamos el metodo commentable() para indicar que se trata de una relación polimorfica
```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Comment extends Model
{
    use HasFactory;

    public function commentable(){
      return $this->morphTo();
    }
}

```

En el modelo Post agregamos el metodo
```php
    // Relación uno a muchos polimorfica
    public function comment(){
      return $this->morphToMany('App\Models\Comment', 'commentable');
    }
```

y en el modelo Video pegamos este mismo codigo anterior
```php
    // Relación uno a muchos polimorfica
    public function comment(){
      return $this->morphToMany('App\Models\Comment', 'commentable');
    }
```

## Relacion muchos a muchos polimorfica


Para ejemplificar esto creamos un modelo Tag, con un campo nombre
```
php artisan make:model Tag -m
```

Luego creamos la migración que va a relacionar las diferentes tablas
```php
php artisan make:migration create_taggables_table
```

Archivo del modelo Post
```php
    // Relacon muchos a muchos polimorfica
    public function posts(){
        return $this->morphToMany('App\Models\Tag','taggable');
    }
}
```


igual ocurre con video, ahora como ambos hace uno de tags el modelo tag si tiene algo diferente
```php
// archivo Models\Tag.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Tag extends Model
{
    use HasFactory;

    public function posts(){
      return $this->morphedByMany('App\Models\Posts', 'taggable');
    }

    public function videos(){
      return $this->morphedByMany('App\Models\Video', 'taggable');
    }

}

```